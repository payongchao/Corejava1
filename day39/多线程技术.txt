多线程技术：

进程：正在进行（运行）中的程序。可以理解为
      操作系统为某一应用程序所分配的内存资源。

线程：线程是来执行具体的某一个任务的最小单位，
      也称为最小执行单元。也称为执行路径。
      一个进程中至少有一个线程。

多线程：一个进程中存在多个线程。
       能解决什么问题？解决了对于CPU资源的合理应用。

自定义线程类：
有两种方式：
    1.让自定义的类继承Thread类。重写run方法。（创建线程）
    java.lang.Thread类：run方法，当在自定义一个线程类的时候，
    需要重写父类Thread类中的run方法，该方法中的代码就是
    该线程所要执行的任务。要使该run方法执行，不能直接调用
    该run方法，需要调用父类中的start();方法。（启动线程）

    2.自定义类实现Runnable接口。实现run方法。
    创建该自定义类的对象。
    创建线程对象，让该自定义类的对象作为Thread构造器的
    参数传递。通俗理解：让线程和资源产生关系。
    最后让线程对象调用start方法来启动线程。

    class Ticket{}

    class PlaneTicket ex Ticket impl Runnable{
        run(){

        }
    }

    class Test{
        main(){
            Thread t=new Thread(new Demo()); // 创建了线程
            t.start();             // 启动线程
        }
    }

多线程的特点：
    1.多个线程之间的执行没有顺序，CPU调度到谁，谁执行。
      可以看做是多个线程在抢占CPU资源，谁抢到谁执行。
    2.主线程结束，并不意味着该程序所对应的进程结束。当该进程
      中的所有线程都执行完毕之后，该进程会退出内存。

线程的运行状态/生命周期：

被创建状态：线程对象被创建了。
运行状态：  线程对象调用了start();方法，启动了线程。
睡眠状态：  调用sleep方法或者wait方法进入该状态，
           该状态也称等待状态。
消亡状态：  线程中的run方法的全部代码运行完毕，自动消亡；
           线程对象调用stop方法，被销亡。
临时阻塞状态：CPU在某个时刻只能调度一个线程，其他的线程
             所处的状态就是该状态。

小结：
1.多线程技术所解决的问题？？？
    能够合理利用CPU资源。
2.创建线程的方式？
    2种；第一种是继承Thread类，但是不推荐使用这种方式，因为
         这种方式是将资源和线程联系在一起，耦合度高。
         第二种是实现Runnable接口。推荐使用这种方式。
3.线程的运行状态？
    线程被创建；
    运行状态；
    消亡状态；
    睡眠状态；
    临时阻塞状态。

多线程的数据安全问题：

出现安全问题的原因：
1.CPU可能会随时切换到其他线程上去执行。
2.多个线程对共享数据都做了更改共享数据原有状态的操作。
  只要多个线程对共享数据做修改操作，那么就有可能会出现多线程
  的数据安全问题。

如何解决该安全问题：
同步机制：
线程锁：
安全锁：使用一定的代码将线程所要执行的任务保护起来，
       当有某一个线程在执行该任务时，其他线程不能执行该任务。
       只有当当前线程执行完毕之后，其他线程才能执行。

该代码是：
// 同步代码块
synchronized(任意对象){
    // 需要同步执行的代码块
}

使用同步代码块的前提是：
所有的线程都应该拿到同一个锁对象。
在只有一个线程的情况下，没有必要使用同步代码块。

同步代码的另一种体现方式就是同步方法：
当某个方法中的所有代码都被包含在同步代码块中，这个时候
就可以不使用同步代码块，而使用同步方法。
在同步方法中的锁对象是该方法所在类的对象，即this。

当同步代码块所处的方法是静态方法时：
这时的所对象有两种：
1.创建静态成员的任意对象。
2.使用当前代码所处类的Class对象（类.class）;

死锁：
在同步锁中嵌套同步锁的情况下，有可能会发生死锁。
在面试的过程中，可能会让你写一个死锁代码。

如何避免死锁：避免锁嵌套。

生产者和消费者：
wait()： 线程等待。当前监视器所监视的线程去等待。
         进入等待或者睡眠状态的线程实际上是进入了线程池中；
notify()：唤醒线程池中的任意一个线程。该方法具有不确定性。
notifyAll()：唤醒线程池中的所有线程。

上面的方法都叫监视器方法，这些方法只能有监视器对象调用。
也就是说这些方法只能由锁对象调用。

单例模式：一个类只能产生一个对象。

思路：
    1.私有化构造器。
    2.对外提供获取该类对象的公有方法。

懒汉式（延迟加载模式）：
饿汉式（立即加载模式）：

多线程中的单例模式：推荐使用饿汉式。

如何让线程进入消亡状态：
1.run方法运行结束
2.stop（该方法已过时，不推荐使用）

JDK官方给出的是线程进入消亡状态的方案：使run方法结束->
一般情况是让run方法中的循环结束。
定义一个变量，当变量的值达到某个条件时，跳出循环。

run(){
    int index=0;
    while(true){
        // wait();
        index++;
        if(index>100){
            break;
        }
        // 任务代码
    }
}

interrupt()：中断线程。不是直接让线程结束，而是强制让线程
进入运行状态，然后通过一定的条件判断，最终消亡。

当某个线程进入等待状态时调用该方法，程序会抛出
InterruptedException，在该Exception的catch代码块中，
可以设置相应的标记，让线程结束。

如果线程在调用 Object 类的 wait()、wait(long)
或 wait(long, int) 方法，或者该类的 join()、join(long)、
join(long, int)、sleep(long) 或 sleep(long, int)
方法过程中受阻，则其中断状态将被清除，它还将收到一个
InterruptedException。

多线程程序---并发程序

为什么要使用多线程？
多线程的任务代码特点：循环执行。

一般的线程如何设计：

前台线程：一般创建的线程都是前台线程。

后台线程：只有当前台线程调用setDaemon(true)方法的时候，
         该线程才会成为后台线程，而且需要注意的是该方法
         必须在调用start方法之前调用。

join：当某一个线程调用了该方法，CPU会优先将该线程执行完毕
      之后再去执行其他线程。

yield：暂时让出执行权给其他线程执行，
       本线程暂时处于临时阻塞状态。

------------------------------------------------
线程总结：

进程：系统为某一程序分配的内存资源。
线程：执行进程资源的最小单位。
多线程：在一个进程中存在多个线程“同时”工作的情况。

Java中的线程：使用Thread类描述了线程这一类事物。

创建线程并启动线程：
1.继承Thread类：自定义类继承Thread类，然后重写run方法。
    创建该自定义类的对象并调用start方法启动线程。
2.自定义类实现Runnable接口，实现run方法。
    创建自定义类的对象，然后创建Thread类的对象，将该
    自定义类的对象作为参数传递给Thread的构造器。最后，
    使用Thread类的对象调用start方法启动线程。

线程安全/多线程共享数据安全问题：使用同步锁机制。
1.同步代码块：
synchronized(任意对象){
    // 操作共享数据的代码
}
当同步代码块在非静态方法中时，锁对象可以是任意的，
包括this，而且，推荐使用this。
当同步代码块在静态方法中时，锁对象是除了this之外任意的，
但是推荐当前类所对应的Class对象。

2.同步方法
    a.同步非静态方法：this
        public synchronized void show(){}
    b.同步静态方法：Class对象
        public synchronized static void show(){}

线程的运行状态：
被创建：new Thread();  start()
运行：线程开始运行。
消亡：线程的代码全部运行结束或者线程被强制结束。
睡眠：sleep(time)、wait([time])<--->时间到；notify[All]();
      sleep(time)：释放的是执行权，不释放锁资源。
      wait()：既释放锁资源，也释放执行权。
临时阻塞：能够进入该状态的一般是刚调用start方法或者是从
         睡眠状态唤醒的线程。

死锁：锁嵌套情况。

单例模式：
懒汉式：
出现问题的原因：多个线程操作了共享数据同时更改了共享数据的状态。
解决方案：使用同步机制。为了调高效率，使用双重的if判断。

饿汉式：多个线程使用也没有问题。

中止线程：中止run方法的执行。

1.run方法中是简单的代码：运行完自己结束。
2.run方法中有循环代码：结束循环。
    定义标记，当该标记达到某一条件时，break；
    在循环中有wait方法存在，需要在创建线程的位置调用interrupt
    方法，进行wait状态的中止，wait方法会抛出InterruptedException，
    在该异常处理的catch代码块中使用break结束循环。

join：当某个线程对象调用该方法时，
      CPU优先让该线程执行完毕之后再执行其他线程。

yield：暂时让出执行权让其他线程执行，当其他线程执行完毕
       之后，一般情况下该线程会立刻抢占到CPU资源然后执行。


和线程相关的类中的方法：
Thread（类）：
    *Thread(Runnable r):

    *static currentThread();
    // 返回的的执行调用该方法的方法的线程的对象。

    getName();
    // 返回线程名称，除了主方法外的其他线程，都是按照
    // 线程的创建顺序，然后以“Thread-x”来命名。

    getPriority();
    // 获取线程优先级。1-10，
    setPriority(int);
    // 调整优先级不一定会提高该线程的执行次序

    interrupt();
    // 中断线程的sleep()/wait()状态。

    join([time])：一般CPU会一直执行调用该方法的线程，直到该线程
          运行结束或者是运行时间到，CPU就会执行其他线程。
   *run();
    // 线程执行的任务代码写在该方法中。

   *sleep(time);
    // 让该方法所处的线程休眠time时间。时间到自动恢复。

   *start();
    // 启动线程
    // 和run方法的区别：
    // 如果直接调用run方法，则是普通的方法调用。
    // 如果要启动线程，则需要调用该start方法。

    toString();
    //   返回该线程的字符串表示形式，包括线程名称、优先级和线程组。

    yield();
    // 暂时让出执行权给其他线程执行。当其他线程执行
    // 完毕之后，该线程会立即抢占CPU资源，但是不一定能抢到。

Object（类）：
    notify();
    // 该方法时唤醒线程池中等待的任意一个线程。

    notifyAll();
    // 唤醒线程池中的所有线程

    wait([time]);
    // 让线程进入等待状态；
    // 1.等待其他线程唤醒该线程
    // 2.时间到之后自动唤醒

Runnable（接口）：
    run();
    // 该方法中定义线程要执行的任务代码


