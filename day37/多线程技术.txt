多线程技术：

进程：正在进行（运行）中的程序。可以理解为
      操作系统为某一应用程序所分配的内存资源。

线程：线程是来执行具体的某一个任务的最小单位，
      也称为最小执行单元。也称为执行路径。
      一个进程中至少有一个线程。

多线程：一个进程中存在多个线程。
       能解决什么问题？解决了对于CPU资源的合理应用。

自定义线程类：
有两种方式：
    1.让自定义的类继承Thread类。重写run方法。（创建线程）
    java.lang.Thread类：run方法，当在自定义一个线程类的时候，
    需要重写父类Thread类中的run方法，该方法中的代码就是
    该线程所要执行的任务。要使该run方法执行，不能直接调用
    该run方法，需要调用父类中的start();方法。（启动线程）

    2.自定义类实现Runnable接口。实现run方法。
    创建该自定义类的对象。
    创建线程对象，让该自定义类的对象作为Thread构造器的
    参数传递。通俗理解：让线程和资源产生关系。
    最后让线程对象调用start方法来启动线程。

    class Ticket{}

    class PlaneTicket ex Ticket impl Runnable{
        run(){

        }
    }

    class Test{
        main(){
            Thread t=new Thread(new Demo()); // 创建了线程
            t.start();             // 启动线程
        }
    }

多线程的特点：
    1.多个线程之间的执行没有顺序，CPU调度到谁，谁执行。
      可以看做是多个线程在抢占CPU资源，谁抢到谁执行。
    2.主线程结束，并不意味着该程序所对应的进程结束。当该进程
      中的所有线程都执行完毕之后，该进程会退出内存。

线程的运行状态/生命周期：

被创建状态：线程对象被创建了。
运行状态：  线程对象调用了start();方法，启动了线程。
睡眠状态：  调用sleep方法或者wait方法进入该状态，
           该状态也称等待状态。
消亡状态：  线程中的run方法的全部代码运行完毕，自动消亡；
           线程对象调用stop方法，被销亡。
临时阻塞状态：CPU在某个时刻只能调度一个线程，其他的线程
             所处的状态就是该状态。

小结：
1.多线程技术所解决的问题？？？
    能够合理利用CPU资源。
2.创建线程的方式？
    2种；第一种是继承Thread类，但是不推荐使用这种方式，因为
         这种方式是将资源和线程联系在一起，耦合度高。
         第二种是实现Runnable接口。推荐使用这种方式。
3.线程的运行状态？
    线程被创建；
    运行状态；
    消亡状态；
    睡眠状态；
    临时阻塞状态。

多线程的数据安全问题：

出现安全问题的原因：
1.CPU可能会随时切换到其他线程上去执行。
2.多个线程对共享数据都做了更改共享数据原有状态的操作。
  只要多个线程对共享数据做修改操作，那么就有可能会出现多线程
  的数据安全问题。

如何解决该安全问题：
同步机制：
线程锁：
安全锁：使用一定的代码将线程所要执行的任务保护起来，
       当有某一个线程在执行该任务时，其他线程不能执行该任务。
       只有当当前线程执行完毕之后，其他线程才能执行。

该代码是：
// 同步代码块
synchronized(任意对象){
    // 需要同步执行的代码块
}

使用同步代码块的前提是：
所有的线程都应该拿到同一个锁对象。
在只有一个线程的情况下，没有必要使用同步代码块。

同步代码的另一种体现方式就是同步方法：
当某个方法中的所有代码都被包含在同步代码块中，这个时候
就可以不使用同步代码块，而使用同步方法。
在同步方法中的锁对象是该方法所在类的对象，即this。

当同步代码块所处的方法是静态方法时：
这时的所对象有两种：
1.创建静态成员的任意对象。
2.使用当前代码所处类的Class对象（类.class）;

死锁：
在同步锁中嵌套同步锁的情况下，有可能会发生死锁。
在面试的过程中，可能会让你写一个死锁代码。

如何避免死锁：避免锁嵌套。

生产者和消费者：


































