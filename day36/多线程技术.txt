多线程技术：

进程：正在进行（运行）中的程序。可以理解为
      操作系统为某一应用程序所分配的内存资源。

线程：线程是来执行具体的某一个任务的最小单位，
      也称为最小执行单元。也称为执行路径。
      一个进程中至少有一个线程。

多线程：一个进程中存在多个线程。
       能解决什么问题？解决了对于CPU资源的合理应用。

自定义线程类：
有两种方式：
    1.让自定义的类继承Thread类。重写run方法。（创建线程）
    java.lang.Thread类：run方法，当在自定义一个线程类的时候，
    需要重写父类Thread类中的run方法，该方法中的代码就是
    该线程所要执行的任务。要使该run方法执行，不能直接调用
    该run方法，需要调用父类中的start();方法。（启动线程）

    2.自定义类实现Runnable接口。实现run方法。
    创建该自定义类的对象。
    创建线程对象，让该自定义类的对象作为Thread构造器的
    参数传递。通俗理解：让线程和资源产生关系。
    最后让线程对象调用start方法来启动线程。

    class Ticket{}

    class PlaneTicket ex Ticket impl Runnable{
        run(){

        }
    }

    class Test{
        main(){
            Thread t=new Thread(new Demo()); // 创建了线程
            t.start();             // 启动线程
        }
    }

多线程的特点：
    1.多个线程之间的执行没有顺序，CPU调度到谁，谁执行。
      可以看做是多个线程在抢占CPU资源，谁抢到谁执行。
    2.主线程结束，并不意味着该程序所对应的进程结束。当该进程
      中的所有线程都执行完毕之后，该进程会退出内存。

线程的运行状态/生命周期：

被创建状态：线程对象被创建了。
运行状态：  线程对象调用了start();方法，启动了线程。
睡眠状态：  调用sleep方法或者wait方法进入该状态，
           该状态也称等待状态。
消亡状态：  线程中的run方法的全部代码运行完毕，自动消亡；
           线程对象调用stop方法，被销亡。
临时阻塞状态：CPU在某个时刻只能调度一个线程，其他的线程
             所处的状态就是该状态。

小结：
1.多线程技术所解决的问题？？？
    能够合理利用CPU资源。
2.创建线程的方式？
    2种；第一种是继承Thread类，但是不推荐使用这种方式，因为
         这种方式是将资源和线程联系在一起，耦合度高。
         第二种是实现Runnable接口。推荐使用这种方式。
3.线程的运行状态？
    线程被创建；
    运行状态；
    消亡状态；
    睡眠状态；
    临时阻塞状态。

多线程的安全问题：
































