Collection：
常用的方法：

添加：
    *add(obj);
    // 添加单个元素

    addAll(coll);
    // 添加一组元素

移除：
    *remove(obj);
    // 移除单个元素
    removeAll(coll);
    // 移除一组元素，移除指定的集合和原集合相同的元素。
    retainAll(coll);
    // 移除一组元素，
    // 移除的是原集合中和指定集合中不相同的元素。（取交集）
    clear();
    // 移除所有的元素

修改：
    在Collection中没有和修改操作相关的方法。

查询：
    iterator();
     // 获取在该集合中的元素上进行迭代的迭代器

获取集合长度：
    *size();

判断：
    *contains(obj);
    // 判断该集合中是否包含指定的元素
    containsAll(coll);
    // 判断该集合中是否包含指定的一组元素
    // （指定的集合中的所有元素）
    isEmpty();
    // 判断该集合是否为空（如果集合的size==0，该集合为空）

将集合转化成数组：
    toArray();
    toArray([]);
-----------------------------------
List：有序的集合。
          添加到集合中的元素的顺序
          和从该集合中取出元素的顺序是一致的。
      允许重复的元素。
List的特有方法：
添加：
    add(index,obj);
    // 向指定的位置插入单个元素
    addAll(index,list);
    // 向指定的位置插入一组元素
移除：
    remove(index);
    // 移除该集合中的指定位置上的元素
修改：
    set(index,obj);
    // 更改指定位置上的元素，更改之后的元素为obj
查询：
    get(index);
    // 返回该集合中的指定位置上的元素
    indexOf(obj);
    // 返回的是该元素在该集合中第一次出现的索引。
    lastIndexOf(obj);
    // 返回的是该元素在该集合中最后一次出现的索引。
    listIterator();
    // 返回的是ListIterator迭代器对象。
    listIterator(index);
    // 返回ListIterator迭代器对象，
    // 但是是从该集合的指定索引位置开始迭代。

其他特有方法：
    subList(start,end);
    // 返回的是从start索引位置（包含）
    // 到end索引位置（不包含）
    // 对原始集合进行截取所形成的新集合。
-----------------------------------------
ArrayList：
    特点：数据结构（数据的存储方式）是数组。
          查询很快，但是插入和删除较慢。
LinkedList：链接列表，链表
    特点：数据结构是链表。
          插入和删除很快，但是查询较慢。
    特有方法：
        addFirst();
        addLast();

        removeFirst();
        removeLast();

        // 下面这俩是获取并且移除
        pollFirst();
        pollLast();

        // 下面这俩是获取但不移除
        peekFirst();
        peekLast();

练习1：使用List集合存储N个字符串。
实现功能：对该集合中的字符串去重。

练习2：使用List集合存储Student(name,age)对象。
实现功能：对该集合中的Student对象去重。
对于Student对象“重复”的定义：
        认为姓名和年龄都相同的是同一个Student对象。
-----------------------------------------
Set集合：
    1.不允许重复元素。
    2.无序的。

    特有方法：无
实现类：
    HashSet：数据结构（数据存储方式）是哈希表。
        增：add(obj);
            // 当指定的元素不存在于该集合中的时候，
            // 添加指定的元素到该集合中。意味着如果
            // 该集合中存在指定的元素，则不添加。
        删：remove(obj);
            // 如果存在则删除，返回true；
            // 如果不存在，返回false。
            clear(); // 清空该集合
        改：无
        查：iterator(); // 迭代遍历该集合中的元素
        判断：contains(obj);
             // 判断指定的元素是否在该集合中
             isEmpty();
             // 通过size()方法判断该集合是否为空。
    TreeSet：
        特有方法：
            ceiling(obj);
            // 返回的是大于等于给定的元素的最小值
            higher(obj);
            // 返回的是严格大于给定的元素的最小值
            floor(obj);
            // 返回的是小于等于给定的元素的最大值
            lower();
            // 返回的是严格小于给定的元素的最大值
            fisrt();
            // 返回此集合中的第一个（最低）元素
            last();
            // 返回此集合中的最后一个（最高）元素

        特点：能够对集合中的元素按照自然顺序（从小到大）
              进行排序。
              他的数据结构是二叉树结构。

        作业：实现学生信息管理系统。
              Student(id,name,age,gender,grade);
              当上面的所有信息都相同的时候认为是同一个学生。
        功能：1.能对学生进行增删改查操作。
              2.能够按照学生的学号进行从小到大的排列。
              *.能够按照学生的学号进行从小到大或者从大到小的排列。
              3.能够按照性别和姓名以及年龄进行排序，
                如果上面都满足，按照学号排。
---------------------------------------------
Comparable和Comparator：
Comparable：强行规定了实现该接口的类具有可比较性。
让元素具有可比较性，TreeSet能够根据元素的可比较性进行自然排序。
Comparator：比较器。
传递给TreeSet，更改的是TreeSet的比较规则。
用处：当无法修改集合的元素所属类的比较规则的时候，并且该类内置的比较规则（compareTo方法的方法体）不符合现在的需求，就需要自定义比较规则。由于无法修改元素的比较规则，只能修改集合的比较规则。
TreeSet是具有比较或者排序功能，排序的默认参照（规则）是该集合中所存储的元素所属类的compareTo()方法；在不能更改元素所属类的源码的情况下，又要重新定义比较规则，只能使用Comparator，将Comparator接口的实现类的对象传递给TreeSet的构造器，就能覆盖默认的比较规则，是因为Comparator的优先级比Comparable高。
---------------------------------------------------
泛型：泛指的类型。Generic
语法：类<数据类型对应的类>
例子：在List集合中存储 的都是String。
      List<String> list=new ArrayList<String>();
在JDK1.7之前的版本中，这两处泛型参数都必须写；
在JDK1.7之后的版本中，实例化对象的泛型参数可以不写。

泛型一般是用在集合中，用来规定集合中所存储的数据类型，
以避免在后边操作集合的时候出错。

泛型参数：一般是在类名后面的括号“<>”中的参数。
         传递的是数据类型。

形式参数：方法名后面的括号中“()”的参数。
         传递的是数据的值。

自定义泛型类：在定义类的时候，在类名后面通过“<>”
             指定泛型参数即可。
例子：public class Tool<O>{}

自定义泛型接口：在定义接口的时候，在接口名后面通过“<>”
               指定泛型参数即可。
例子：interface Tool<O>{}

自定义泛型方法：在定义方法的时候，在返回值前面通过“<>”
               指定泛型参数即可。
例子：public <W> void print(W w){}

泛型通配符：?
    当不确定该集合中应该存储什么数据类型的时候，
    可以使用泛型通配符。
    List<?> list=new ArrayList();

    泛型通配符一般是在方法的形参中使用，在创建相关对象
    并且实例化的时候是不能使用泛型通配符的。

<? extends E>：能操作的都是E的子类。
<? super E>：能操作的都是E的所有父类。
-----------------------------------------------
Map：映射关系。Map实际上不属于集合框架的一部分，但是它具有
     和集合类似的功能——能存储数据。
特点：
     Map存储数据的结构是键值对的形式。
     Map对象是将键映射到值的对象。
     Map中所存储的数据（键值对）的键是不能重复的；
        但是值是可以重复的。
     Map中的每个键最多只能映射到一个值。
     Map中的键可以为null，但是键只能出现一个null；
        但是值是任意的。

共有方法：
    clear();
    // 从此集合中移除所有的映射关系。

    containsKey(obj);
    // 判断该集合中是否包含指定的键
    containsValue(obj);
    // 判断该集合中是否包含指定的值

    V get(key);
    // 传递的参数为键，返回值为映射关系的值

    V put(k,v);
    // 向集合中添加键值对，
    // 返回的是该k在该集合中对应的原有的值。
    void putAll(map);
    // 将指定的集合中的所有映射关系（键值对）添加到原集合中
    // 但是如果键重复了，覆盖原有的值

    Set<K> keySet();
    // 该方法能够返回此集合中所有的键，
    // 这些所有的键被存储到了Set集合中。

    V remove(key);
    // 从原集合中删除和参数key对象的映射关系（键值对），
    // 返回的是该key在原集合中对应的值

    Collection<V> values();
    // 该方法返回原集合中的所有值组成的Collection集合。

    Set<Map.Entry<K,V>> entrySet();
    // 该方法返回的是原集合中所有的键值对所形成的Set集合。
    // Map中对该键值对进行了进一步封装，所形成的数据类型
    // 是Entry<K,V>

Map的实现类：
Hashtable：
    数据结构是哈希表；存储的是键值对，键和值不允许null。
HashMap：
    数据结构是哈希表；存储的是键值对，键和值可以为null；
    与Hashtable不同的是：
        1.HashMap是不同步的，Hashtable是同步的。
        2.HashMap允许null键和null值，但是Hashtable不允许。
特有方法：无
TreeMap：
    数据结构是红黑树；默认情况下能够通过键的自然顺序进行排序。
    或者按照创建TreeMap对象时提供的Comparator进行排序。

默认按照键的自然顺序进行排序：
TreeSet/TreeMap中的键里存储的元素必须具有可比较性。
如果是自定义的类，要让其具有可比较性，实现Comparable接口。
这样的顺序叫自然顺序。

特有方法：和TreeSet中的特有方法几乎一致，但是TreeMap中
          没有peek相关方法。
-------------------------------------------------
集合框架总结：
Iterable
    |---Collection
            |---List
                  |---ArrayList：
                  |---LinkedList：
            |---Set
                  |---HashSet：
                  |---TreeSet：
Map：
  |---HashMap：
  |---TreeMap：

*ArrayList：数据结构是数组。有索引。查询快。但是增删较慢。
           可以使用在一次存储，多次查询的情况。
LinkedList：链表。查询慢，但是增删很快。
           适用于多次修改的情况。

HashSet：数据结构哈希表。无序（hashCode影响的），
         不可重复（hashCode和equals影响的）。
         一般用在对其他集合中的数据进行去重。

TreeSet：数据结构二叉树。无序（compareTo影响的），
         不可重复（也是compareTo方法影响）。
         一般用在对其他集合中的数据进行排序。

*HashMap：数据结构哈希表。无序，键不可重复，值可以重复。
         键和值都可以为null。一个键只能对应一个值。
         主要用在具有映射关系的数据上。

TreeMap：数据结构红黑树。无序，会按照键排序。
         键不可重复，值可以重复。
         主要用在具有映射关系的数据上，主要用来对键排序。
----------------------------------------------------
Collections：操作集合的工具类。
    方法：
         addAll(Collection<T> coll,T...es);
         // 将一组指定的元素添加到指定的集合中。
         fill(list,obj);
         // 将指定的集合中的所有元素都替换成同一个值
         sort(list);
         // 将指定的集合按照自然顺序进行升序排序
         sort(list,comparator);
         // 将指定的集合按照指定的比较器中规定的顺序进行排序

Arrays：操作数组的工具类。
    List<T> asList(T...es);
    // 将指定的一组数据类型相同的元素转成长度固定的List集合。
    // 该转化之后的List集合只能做查询和修改操作。不能做
    // 增删操作。也就是不能改变集合的长度。
    // 此方法可以将数组转化成集合，
    // 但是转化之后的集合具有局限性。

集合转化成数组呢？
    在Arrays里有将数组转化成集合的方法。在Collections
    中没有将集合转化成数组的方法。但是在Collection中有
    将集合转化成数组的方法。

    toArray();
    // 将此集合中所有元素封装到数组中返回。
    toArray(T[] a);
    // 将此集合中的所有元素封装到指定的数组中返回。


可变长参数：T...args
















-----------------------------------------------
foreach，增强for循环：
for(变量的定义:容器){
	// 其他操作
}
“变量的定义”中的变量的数据类型是什么？
数组：是定义该数组时的数据类型。
集合：就目前所学，是Object。
     原因是集合可以存储任意引用类型的数据，在学习泛型之前，
     也就是说在定义集合的时候没有添加泛型，Java虚拟机认为
     该集合中存储的都是Object类型的数据，实际上是进行了
     向上转型。所以在遍历的时候，如果不使用该元素中的
     特有属性或者特有方法，不需要向下转型。如果要使用，
     则需要向下转型（数据类型的强制转换）；
























