多线程技术：

进程：正在进行（运行）中的程序。可以理解为
      操作系统为某一应用程序所分配的内存资源。

线程：线程是来执行具体的某一个任务的最小单位，
      也称为最小执行单元。也称为执行路径。
      一个进程中至少有一个线程。

多线程：一个进程中存在多个线程。
       能解决什么问题？解决了对于CPU资源的合理应用。

自定义线程类：
有两种方式：
    1.让自定义的类继承Thread类。重写run方法。（创建线程）
    java.lang.Thread类：run方法，当在自定义一个线程类的时候，
    需要重写父类Thread类中的run方法，该方法中的代码就是
    该线程所要执行的任务。要使该run方法执行，不能直接调用
    该run方法，需要调用父类中的start();方法。（启动线程）

    2.自定义类实现Runnable接口。实现run方法。
    创建该自定义类的对象。
    创建线程对象，让该自定义类的对象作为Thread构造器的
    参数传递。通俗理解：让线程和资源产生关系。
    最后让线程对象调用start方法来启动线程。

    class Ticket{}

    class PlaneTicket ex Ticket impl Runnable{
        run(){

        }
    }

    class Test{
        main(){
            Thread t=new Thread(new Demo()); // 创建了线程
            t.start();             // 启动线程
        }
    }

多线程的特点：
    1.多个线程之间的执行没有顺序，CPU调度到谁，谁执行。
      可以看做是多个线程在抢占CPU资源，谁抢到谁执行。
    2.主线程结束，并不意味着该程序所对应的进程结束。当该进程
      中的所有线程都执行完毕之后，该进程会退出内存。

线程的运行状态/生命周期：

被创建状态：线程对象被创建了。
运行状态：  线程对象调用了start();方法，启动了线程。
睡眠状态：  调用sleep方法或者wait方法进入该状态，
           该状态也称等待状态。
消亡状态：  线程中的run方法的全部代码运行完毕，自动消亡；
           线程对象调用stop方法，被销亡。
临时阻塞状态：CPU在某个时刻只能调度一个线程，其他的线程
             所处的状态就是该状态。

小结：
1.多线程技术所解决的问题？？？
    能够合理利用CPU资源。
2.创建线程的方式？
    2种；第一种是继承Thread类，但是不推荐使用这种方式，因为
         这种方式是将资源和线程联系在一起，耦合度高。
         第二种是实现Runnable接口。推荐使用这种方式。
3.线程的运行状态？
    线程被创建；
    运行状态；
    消亡状态；
    睡眠状态；
    临时阻塞状态。

多线程的数据安全问题：

出现安全问题的原因：
1.CPU可能会随时切换到其他线程上去执行。
2.多个线程对共享数据都做了更改共享数据原有状态的操作。
  只要多个线程对共享数据做修改操作，那么就有可能会出现多线程
  的数据安全问题。

如何解决该安全问题：
同步机制：
线程锁：
安全锁：使用一定的代码将线程所要执行的任务保护起来，
       当有某一个线程在执行该任务时，其他线程不能执行该任务。
       只有当当前线程执行完毕之后，其他线程才能执行。

该代码是：
// 同步代码块
synchronized(任意对象){
    // 需要同步执行的代码块
}

使用同步代码块的前提是：
所有的线程都应该拿到同一个锁对象。
在只有一个线程的情况下，没有必要使用同步代码块。

同步代码的另一种体现方式就是同步方法：
当某个方法中的所有代码都被包含在同步代码块中，这个时候
就可以不使用同步代码块，而使用同步方法。
在同步方法中的锁对象是该方法所在类的对象，即this。

当同步代码块所处的方法是静态方法时：
这时的所对象有两种：
1.创建静态成员的任意对象。
2.使用当前代码所处类的Class对象（类.class）;

死锁：
在同步锁中嵌套同步锁的情况下，有可能会发生死锁。
在面试的过程中，可能会让你写一个死锁代码。

如何避免死锁：避免锁嵌套。

生产者和消费者：
wait()： 线程等待。当前监视器所监视的线程去等待。
         进入等待或者睡眠状态的线程实际上是进入了线程池中；
notify()：唤醒线程池中的任意一个线程。该方法具有不确定性。
notifyAll()：唤醒线程池中的所有线程。

上面的方法都叫监视器方法，这些方法只能有监视器对象调用。
也就是说这些方法只能由锁对象调用。

单例模式：一个类只能产生一个对象。

思路：
    1.私有化构造器。
    2.对外提供获取该类对象的公有方法。

懒汉式（延迟加载模式）：
饿汉式（立即加载模式）：

多线程中的单例模式：推荐使用饿汉式。

如何让线程进入消亡状态：
1.run方法运行结束
2.stop（该方法已过时，不推荐使用）

JDK官方给出的是线程进入消亡状态的方案：使run方法结束->
一般情况是让run方法中的循环结束。
定义一个变量，当变量的值达到某个条件时，跳出循环。

run(){
    int index=0;
    while(true){
        // wait();
        index++;
        if(index>100){
            break;
        }
        // 任务代码
    }
}

interrupt()：中断线程。不是直接让线程结束，而是强制让线程
进入运行状态，然后通过一定的条件判断，最终消亡。

当某个线程进入等待状态时调用该方法，程序会抛出
InterruptedException，在该Exception的catch代码块中，
可以设置相应的标记，让线程结束。

如果线程在调用 Object 类的 wait()、wait(long)
或 wait(long, int) 方法，或者该类的 join()、join(long)、
join(long, int)、sleep(long) 或 sleep(long, int)
方法过程中受阻，则其中断状态将被清除，它还将收到一个
InterruptedException。

多线程程序---并发程序

为什么要使用多线程？
多线程的任务代码特点：循环执行。

一般的线程如何设计：

前台线程：一般创建的线程都是前台线程。

后台线程：只有当前台线程调用setDaemon(true)方法的时候，
         该线程才会成为后台线程，而且需要注意的是该方法
         必须在调用start方法之前调用。




























